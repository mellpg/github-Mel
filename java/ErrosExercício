1️⃣ Construtor sem argumentos chamando campos diretamente
public Manager() {
    super(code, name, address, age, salary); // ERRADO
}


Erro: Não é possível usar campos de instância (code, name, etc.) antes de chamar super().
Correção: Use valores literais ou padrões:

public Manager() {
    super("", "", "", 0, 0); // Inicializa com valores padrão
}


Anotação: Sempre que fizer construtor sem argumentos, inicialize atributos da superclasse com valores fixos ou defaults.

2️⃣ Duplicidade de métodos getFullSalary

Você tinha isso no Employee:

public abstract double getfullSalary();
public double getFullSalary() { return 0; }


Erro: O compilador exige que a subclasse implemente todos os métodos abstratos.
Correção: Mantenha apenas um método abstrato e implemente corretamente nas subclasses:

public abstract double getFullSalary();


Anotação: Não crie métodos duplicados com nomes iguais, mas diferentes maiúsculas/minúsculas (getfullSalary vs getFullSalary).

3️⃣ @override em classe

Você colocou:

public non-sealed class Manager extends Employee {
    @override
    ...
}


Erro: @Override não pode ser usado na declaração da classe; só em métodos.
Correção: Remova de cima da classe. Use somente em métodos que sobrescrevem métodos da superclasse:

@Override
public String getCode() { ... }


Anotação: @Override indica que você está sobrescrevendo um método, nunca a classe.

4️⃣ Usar non-sealed sem necessidade
public non-sealed class Manager extends Employee


Erro: O Eclipse pode sugerir @Override se você tentar sobrescrever algo errado.
Anotação: non-sealed é só pra permitir que futuras classes possam estender; não é obrigatório se não tiver herança adicional.

5️⃣ Chamando super() com variáveis de instância

Mesmo erro do ponto 1. Exemplo errado:

super(code, name, getAdress(), age, salary);


Erro: Variáveis de instância (code, name, age) não existem ainda quando você chama super().
Correção: Use valores padrão ou passe os parâmetros do construtor:

super(code, name, address, age, salary);


Anotação: super() precisa de valores já conhecidos, não pode depender de campos da própria instância que ainda não existem.
